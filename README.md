# User Voting System

## Project Description
The **User Voting System** is a web and API-based application designed to allow users to register, log in, and vote for other users, with an admin panel to manage users and monitor voting statistics. This project was developed as per the provided specifications, utilizing modern development practices and design patterns to ensure scalability, maintainability, and flexibility.

### What I Did in This Project
- **Architecture**: Implemented the **Repository Design Pattern** to abstract database operations and improve code maintainability, alongside **Service Classes** to encapsulate business logic for voting and user management.
- **Database Relationships**: Used a direct foreign key relationship between the User and Vote models instead of a polymorphic relationship. While polymorphic relationships offer flexibility for future extensions (e.g., voting on posts or comments), I opted for simplicity and performance since the current scope only involves voting between users. Polymorphic relationships are more complex to set up and query due to the type column and can be marginally slower, which wasn’t justified for this use case.
- **Initial Setup**: Created a `UserSeeder` to populate the database with an admin user (email: `moamen@example.com`, password: `12345678`) and sample users for testing.
- **Code Quality**: Refactored the `vote` function in `VoteService` to adhere to the **Open/Closed Principle (OCP)** using the **Strategy Pattern**. This ensures the system can accommodate new voting rules without modifying existing code.
- **Tech Stack**: Built with Laravel (Blade + API), Bootstrap for frontend styling, MySQL for the database, JWT for API authentication, and Laravel Breeze for web authentication.

## System Requirements
- **PHP**: 8.1 or higher
- **Composer**: Latest version
- **Node.js & NPM**: For frontend assets (if needed)
- **Git**: For cloning the repository

## Installation Guide
Follow these steps to set up the project locally:

1. **Clone the Repository**
   ```bash
   git clone https://github.com/Abdelrahmanm22/Voting-System-Task.git
   cd Voting-System-Task
   ```

2. **Install Dependencies**
   ```bash
   composer install
   ```

3. **Configure Environment**
   - Copy the `.env.example` file to `.env`:
     ```bash
     cp .env.example .env
     ```
   - Update the `.env` file with your database credentials:
     ```
     DB_CONNECTION=mysql
     DB_HOST=127.0.0.1
     DB_PORT=3306
     DB_DATABASE=votingdb
     DB_USERNAME=your_username
     DB_PASSWORD=your_password
     ```
   - Generate an application key:
     ```bash
     php artisan key:generate
     ```


4. **Run Migrations and Seeders**
   ```bash
   php artisan migrate
   php artisan db:seed
   ```
   This will create the database tables and populate them with an admin user (`moamen@example.com`, `12345678`) and sample users.

5. **Run the Application**
   ```bash
   php artisan serve
   ```
   Access the app at `http://localhost:8000`.

## Configuration Steps
- Ensure the `.env` file is correctly configured with your database details.
- For API usage, test the endpoints (e.g., `/api/register`, `/api/login`) using tools like Postman with the JWT token after login.


## Running the Project
- **Web Interface**: Visit `http://localhost:8000` after starting the server.
- **API**: Use the provided endpoints (e.g., `GET /api/users`, `POST /api/vote`) with a valid JWT token.
- **Admin Access**: Log in with `moamen@example.com` and `12345678` to manage users and view statistics.

## Sample Environment Variables
```env
APP_NAME="User Voting System"
APP_ENV=local
APP_KEY= (generated by php artisan key:generate)
APP_DEBUG=true
APP_URL=http://localhost

DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=votingdb
DB_USERNAME=root
DB_PASSWORD=

JWT_SECRET= (generated by php artisan jwt:secret)
```

---

**Refactoring with Strategy Pattern and OCP**  
   - **Why It Matters**: The original `vote` function in `VoteService` violated the Open/Closed Principle (OCP), meaning new voting rules would require modifying existing code. I refactored it using the Strategy Pattern, allowing new rules to be added via separate classes without altering the core logic.
   - **Impact**: This adherence to SOLID principles enhances the system’s maintainability and extensibility, reflecting my commitment to writing high-quality, professional code.

My work goes meeting basic requirements. I incorporated design patterns, made pragmatic decisions about database relationships, and ensured a smooth setup process—all of which demonstrate my technical expertise, practical judgment, and dedication to delivering efficient, robust solutions.


Thank you for considering my efforts!  
Best regards,  
[Abdelrahman]  

--- 
